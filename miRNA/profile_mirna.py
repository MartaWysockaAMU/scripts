import os
import sys
import subprocess
import codecs
from numpy.core.numeric import count_nonzero
import pysam
from collections import namedtuple as nt
import statistics
from miRNA_profiler import reference
from modules import reduction
from Bio import SeqIO
from mimetypes import guess_type
from Bio.SeqIO.FastaIO import SimpleFastaParser
import gzip
from functools import partial



class Profile():
    #def __init__(self, out: str, outdir: str):
    def __init__(self, out: str):#, outdir: str):
        self.miRNA_dict = {}
        self.org_list = {} # key = organism name, val = shortcut
        self.org_score = {} #key = organism shortcut, val = score (how many miRNAs are in miRBase)
        #self.out = out
        self.out_prefix = out #CHANGE
        #self.out_dir = outdir
        self.precursors_file = ""
        self.all_reads_file = ""
        self.test_line = '### merged reads made by '
        self.test_line += 'miRNA_profiler.py merge_reads ###\n'
        self.known = {}
        self.bt_index = ""
        self.names = {} #key = mature miRNA, value = pre-miRNA

    def input_reference(self, ref_dir: str):
        """Read references files into variables

        Args:
            ref_dir (str): path to directory with references files

        Returns:
            self.org_score, self.miRNA_dict, self.known
        """
        
        try:
            os.path.exists(ref_dir)
        except FileNotFoundError:
            msg = "No such directory as: {d}\n".format(d=ref_dir)
            self.exception_handling(msg)

        for ref in os.listdir(os.path.dirname(ref_dir)):
            f = os.path.join(os.path.dirname(ref_dir),ref)
            if self.is_file(f) and\
                not self.is_empty(f):
                if "_miRNA_dat.txt" in ref:
                    with open(f, 'r') as miRNA_dat:
                        for line in miRNA_dat:
                            mirna = line.split("\t")[0]
                            info = line.strip().split("\t")[1:]
                            self.miRNA_dict[mirna] = info
                            miRNAs = info[8].split(", ")
                            for mi in miRNAs:
                                if mi not in self.names:
                                    self.names[mi] = [mirna]
                                else:
                                    self.names[mi].append(mirna)
                elif "_org_list.txt" in ref:
                    with open(f, 'r') as org_list:
                        for line in org_list:
                            org = line.strip().split("\t")[-1]
                            sh = line.strip().split("\t")[0]
                            self.org_list[org] = sh
                elif "_org_score.txt" in ref:
                    with open(f, 'r') as org_list:
                        for line in org_list:
                            [org, score] = line.strip().split("\t")#[0]
                            self.org_score[org] = score
                elif "_precursors.fasta" in ref:
                    self.precursors_file = f #os.path.join(ref_dir,ref)
                elif "_known_miRNAs.txt" in ref: # TODO nie jest tu potrzebny tylko do validacji
                    with open(f, 'r') as miRNA_list:
                        for mirna, seq in SimpleFastaParser(miRNA_list):
                            if mirna not in self.known:
                                self.known[mirna] = seq
                    '''mirna = line.strip().split("\t")[0]
                    chrom = line.strip().split("\t")[1]
                    start = line.strip().split("\t")[2]
                    stop = line.strip().split("\t")[3]
                    strand = line.strip().split("\t")[4]
                    info = [chrom, start, stop, strand]
                    if info not in self.known:
                        self.known[info] = mirna
                    else:
                        self.known[info].append(mirna)'''
                elif ".ebwt" in ref:
                    index = f
                    if ".rev." in ref:
                        self.bt_index = ".".join(index.split(".")[:-3])
                    else:
                        self.bt_index = ".".join(index.split(".")[:-2])

        return self.org_score, self.miRNA_dict, self.known

    def check_input_reads(self, path: str):
        """Check if reads input file was generated by merge_reads from miRNA_profiler.py
        
        Arguments:
            path (str): path to file
        
        """
        encoding = guess_type(path)[1]
        _open = partial(gzip.open, mode='rt') if encoding == 'gzip' else open
        self.all_reads_file = path
        if self.is_file(path) and\
           not self.is_empty(path):
            
            count_rec = 0
            count_lines = 0
            with _open(path) as handle:
                records = list(SeqIO.parse(handle, "fasta"))
            if any(records):
                '''with _open(path) as handle:
                    for line in handle:
                        count_lines += 1
                        if line.startswith(">"):
                            count_rec += 1'''
                #if len(records) == count_rec and len(records) == float(count_lines/2):
                    #check if every has sequence
                incorrect_seq = any([True for r in records if r.seq == ''])
                if incorrect_seq:
                    msg = "Some records in provided file {f} are corrupted\n".format(f=path)
                    self.exception_handling(msg)
                else:
                    try: #if it is collapsed with "_x" separator   
                        int(records[0].name.strip().split("_x")[-1])
                    except ValueError:
                        msg = "Provided fasta file {f} has incorrect header format. Collapsing separator should be '_x'\n \
                                Perform merge_reads option in miRNA_profiler\n".format(f=path)
                        self.exception_handling(msg)
                    sample = records[0].name.split("_x")[0].split(".")
                    if len(sample) < 2:
                        try:
                            int(sample[-1])
                        except ValueError:
                            msg = "Provided fasta file {f} has incorrect header format. There should be sample.readNumber_xCollapseNr format\n \
                                    Perform merge_reads option in miRNA_profiler\n".format(f=path)
                            self.exception_handling(msg)
                #else:
                #    msg = "Some records in provided file {f} are corrupted\n".format(f=path)
                #    self.exception_handling(msg)
            else:
                msg = "Provided file {f} is not in FASTA format\n".format(f=path)
                self.exception_handling(msg)
        else:
            msg = "Provided file {f} doesn't exist or is empty\nMake sure you used correct file\n".format(f=path)
            self.exception_handling(msg)

    def mapping(self, v: int, p: int):
        """ Mapping reads to pre-miRNA sequences with bowtie
        Constat programm parameters:
        -Sa (S - sam output, a - Report all valid alignments per read or pair.)
        -q (With this option bowtie-build will print only error messages.)
        --best (Make Bowtie guarantee that reported singleton alignments are "best" in terms of stratum and in terms of the quality values at the mismatched position(s))
        --strata (If many valid alignments exist and are reportable and they fall into more than one alignment "stratum", report only those alignments that fall into the best stratum. By default, Bowtie reports all reportable alignments regardless of whether they fall into multiple strata. When --strata is specified, --best must also be specified.)
        --fullref (Print the full refernce sequence name, including whitespace, in alignment output.)
        --norc (If --norc is specified, bowtie will not attempt to align against the reverse-complement reference strand.)
        --un <filename> (Write all reads that could not be aligned to a file with name <filename>.)
        User programm parameters:
        -v <int> (Report alignments with at most <int> mismatches.)
        -p <int> (Launch <int> parallel search threads.)
        Saving mapping output to ..._all_reads_merged.sam

        Arguments:
            v (int): parameter for bowtie
            p (int): parameter for bowtie
        Returns:
            name (str): name of a result .sam file
        """
        
        # bowtie
        cmd = 'bowtie -Sa -f --best --strata -v {v_val} -p {p_val} --fullref --norc --no-unal --un /dev/null {index} {input} {output}tmp.sam'.format(v_val=str(v),p_val=str(p),index=self.bt_index,input=self.all_reads_file,output=self.out_prefix)
        cmd += ' 2>{}bowtie.log'.format(self.out_prefix)  
        stdout = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        output = codecs.decode(stdout.communicate()[0], 'unicode_escape')
        #print(cmd)
        # save sam file

        all_reads_name = os.path.split(self.all_reads_file)[1].split('.')[0] + ".sam"

        name = self.out_prefix + all_reads_name
        # TODO sprawdzić czy ten krok można pominąć jeśli 
        cmd = 'awk \'$2!="4"{print $0}\' '+self.out_prefix+"tmp.sam > "+name # CHANGE MW parsowanie awk
        print(cmd)
        stdout = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        output = codecs.decode(stdout.communicate()[0], 'unicode_escape') # czy ten output jest potrzebny?

        os.remove(self.out_prefix+"tmp.sam")
        #cmd = "sed -i '1 i\\" + self.test_line[:-1] + "' " + self.all_reads_file
        #os.system(cmd)
        return name

    def make_dict_to_reducing(self, mapped_reads: str, shift: int, min_reads: int):
        """        
        1. Using pysam to process SAM file from mapping reads to pre-miRNAs sequences
        2. Checking and counting to which matrue miRNA (5p or 3p) reads are mapped

        Args:
            mapped_reads (str): path to .sam file with mapping results
            shift (int): shift of reads to actual miRNA <int> nt up- and downstream
            min_reads (int): threshold of minimum reads mapped to one miRNAs to considere it

        Returns:
            [type]: [description]
            temp_count_dict (dictionary):  dictionary of names of reads mapped to 5p or 3p miRNA on pre-miRNA (key = pre-miRNA name + 5p/3p) splited into samples
            output_dict (dicrionary): dictionary of reads mapped to mature miRNAs
            samples (list): list of sample files names
            precursors (dictionary): dictionary of pre-miRNAs and reads mapped to them 
            new_names (dictionary): dictionary of new named made by miRNA profiled assigned to original names from miRBase
        """

        sam_file = pysam.AlignmentFile(mapped_reads, check_sq = False, check_header = False)
        samples = []
        temp_count_dict = {}
        output_dict = {}
        precursors = {}
        Info = nt('Info', 'read_name reference_seq start stop collapse')
        new_names = {}
        #for read in sam_file:
        for read in sam_file.fetch(until_eof=True):
            sample = ".".join(read.qname.split('.')[0:-1])  # prefix of reads file name
            if sample not in samples:
                samples.append(sample)
            collapsed_number = int(read.qname.split('_x')[-1])  # nr of collapsed reads
            q_start = read.get_reference_positions()[0] 
            q_stop = read.get_reference_positions()[-1] 
            read_info = Info(read.query_name, read.get_reference_sequence().upper(), q_start, q_stop, collapsed_number )
            mature_names = self.miRNA_dict[read.reference_name][8].split(", ")
            pre_miRNA = read.reference_name

            if "5p" in mature_names[0]:
                rname_5p = mature_names[0]
                if rname_5p + "::" + pre_miRNA not in new_names:
                    new_names[rname_5p + "::" + pre_miRNA] = mature_names[0]
                if len(mature_names) > 1:
                    if "3p" in mature_names[1]:
                        rname_3p = mature_names[1]
                    else:
                        if "mir" in mature_names[1]:
                            rname_3p = "{}-3p".format(mature_names[1]).replace("mir","miR")
                        elif "MIR" in mature_names[1]:
                            rname_3p = "{}-3p".format(mature_names[1]).replace("MIR","miR")
                        else:
                            rname_3p = "{}-3p".format(mature_names[1])
                else:
                    if "mir" in pre_miRNA:
                        rname_3p = "{}-3p".format(pre_miRNA).replace("mir","miR")
                    elif "MIR" in pre_miRNA:
                        rname_3p = "{}-3p".format(pre_miRNA).replace("MIR","miR")
                    else:
                        rname_3p = rname_3p = "{}-3p".format(pre_miRNA)
                    #self.names[pre_miRNA] = self.names[mature_names[0]]
                if rname_3p + "::" + pre_miRNA not in new_names:
                     new_names[rname_3p + "::" + pre_miRNA] = pre_miRNA
            elif "3p" in mature_names[0]:
                rname_3p = mature_names[0]
                if rname_3p + "::" + pre_miRNA not in new_names:
                    new_names[rname_3p + "::" + pre_miRNA] = mature_names[0]
                if len(mature_names) > 1:
                    if "5p" in mature_names[1]:
                        rname_5p = mature_names[1]
                    else:
                        if "mir" in mature_names[1]:
                            rname_5p = "{}-5p".format(mature_names[1]).replace("mir","miR")
                        elif "MIR" in mature_names[1]:
                            rname_5p = "{}-5p".format(mature_names[1]).replace("MIR","miR")
                        else:
                            rname_5p = "{}-5p".format(mature_names[1])
                    if rname_5p + "::" + pre_miRNA not in new_names:
                        new_names[rname_5p + "::" + pre_miRNA] = mature_names[1]
                else:
                    if "mir" in pre_miRNA:
                        rname_5p = "{}-5p".format(pre_miRNA).replace("mir","miR") #TODO pozmieniać, żeby było tak!
                    elif "MIR" in pre_miRNA:
                        print('MIR')
                        rname_5p = "{}-5p".format(pre_miRNA).replace("MIR","miR")
                    else:
                        rname_5p = "{}-5p".format(pre_miRNA)
                    if rname_5p + "::" + pre_miRNA not in new_names:
                        new_names[rname_5p + "::" + pre_miRNA] = pre_miRNA
                    #self.names[pre_miRNA] = self.names[mature_names[0]]
            else:
                if "mir" in mature_names[0]:
                    rname_5p = "{}-5p".format(mature_names[0]).replace("mir","miR")
                    rname_3p = "{}-3p".format(mature_names[0]).replace("mir","miR")
                elif "MIR" in mature_names[0]:
                    rname_5p = "{}-5p".format(mature_names[0]).replace("MIR","miR")
                    rname_3p = "{}-3p".format(mature_names[0]).replace("MIR","miR")
                else:
                    rname_5p = "{}-5p".format(mature_names[0])
                    rname_3p = "{}-3p".format(mature_names[0])
                if rname_5p + "::" + pre_miRNA not in new_names:
                    new_names[rname_5p + "::" + pre_miRNA] = mature_names[0]
                if rname_3p + "::" + pre_miRNA not in new_names:
                    new_names[rname_3p + "::" + pre_miRNA] = mature_names[0]
            ID_5p = rname_5p + "::" + pre_miRNA
            ID_3p = rname_3p + "::" + pre_miRNA

            try:
                coords5p = (int(self.miRNA_dict[pre_miRNA][1]), int(self.miRNA_dict[pre_miRNA][2]))
            except ValueError:
                coords5p = (1, int(self.miRNA_dict[pre_miRNA][3])-1)
            try:
                coords3p = (int(self.miRNA_dict[pre_miRNA][3]), int(self.miRNA_dict[pre_miRNA][4])) 
            except ValueError:
                coords3p = (int(self.miRNA_dict[pre_miRNA][2])+1, len(self.miRNA_dict[pre_miRNA][0])) 
            if coords5p[0] - shift <= 0:
                shifted_start_5p = (1, coords5p[0] + shift)
            else:
                shifted_start_5p = (coords5p[0] - shift, coords5p[0] + shift)
            shifted_end_5p = (coords5p[1] - shift, coords5p[1] + shift)
            shifted_start_3p = (coords3p[0] - shift, coords3p[0] + shift)
            if coords3p[1] + shift > len(self.miRNA_dict[pre_miRNA][0]):
                shifted_end_3p = (coords3p[1] - shift, len(self.miRNA_dict[pre_miRNA][0]))
            else:
                shifted_end_3p = (coords3p[1] - shift, coords3p[1] + shift)

            if sample not in temp_count_dict:  # new_file
                temp_count_dict[sample] = {}
            if ID_5p not in temp_count_dict[sample]:
                temp_count_dict[sample][ID_5p] = 0
            if ID_3p not in temp_count_dict[sample]:  
                temp_count_dict[sample][ID_3p] = 0
            if ID_3p not in output_dict:
                output_dict[ID_3p] = []
            if ID_5p not in output_dict:
                output_dict[ID_5p] = []
            # check if read mapped to 5p or 3p                
            if (shifted_start_5p[0] <= q_start <= shifted_start_5p[1]) or (shifted_end_5p[0] <= q_stop <= shifted_end_5p[1]):
                if str(read.qname) not in output_dict[ID_5p]:#output_dict[rname_5p]:
                    output_dict[ID_5p].append(str(read.qname))
                    temp_count_dict[sample][ID_5p] += collapsed_number
                if pre_miRNA not in precursors:
                    precursors[pre_miRNA] = []
                    precursors[pre_miRNA].append(read_info)
                else:
                    precursors[pre_miRNA].append(read_info)
            if (shifted_start_3p[0] <= q_start <= shifted_start_3p[1]) or (shifted_end_3p[0] <= q_stop <= shifted_end_3p[1]):
                if str(read.qname) not in output_dict[ID_3p]:#output_dict[rname_3p]:
                    output_dict[ID_3p].append(str(read.qname))
                    temp_count_dict[sample][ID_3p] += collapsed_number
                if pre_miRNA not in precursors:
                    precursors[pre_miRNA] = []
                    precursors[pre_miRNA].append(read_info)
                else:
                    precursors[pre_miRNA].append(read_info)
        sam_file.close()
        to_del = []

        #for mi in new_names:
        #    print(mi, new_names[mi])

        #min_reads we wszystkich probkach razem
        for mirna in output_dict:
            c = 0
            for sample in temp_count_dict:
                try:
                    c += temp_count_dict[sample][mirna]
                except KeyError:
                    pass
            if c < min_reads:
                if mirna not in to_del:
                    #print(mirna)
                    to_del.append(mirna)
        #min_reads w kazdej probce osobno
        '''            
        for sample in samples:
            for i in output_dict:
                if (len(output_dict[i]) == 0):
                    if i not in to_del:
                        to_del.append(i)
                try:
                    if (temp_count_dict[sample][i] < min_reads):
                        if i not in to_del:
                            to_del.append(i)
                except KeyError:
                    pass'''

        for i in to_del:
            output_dict.pop(i)
            new_names.pop(i)
        
        '''for key in output_dict:
            line = key + " -> "
            for m in output_dict[key]:
                line += m + "\t"
            line = line.strip()
            print(line)
        sys.exit()'''
#        for i in output_dict:
#            print(i,output_dict[i])
        return temp_count_dict, output_dict, samples, precursors, new_names

    def make_CDHIT_file(self, shift: int, mapped_reads: str, reduction_dict, precursors, new_names) -> None:
        """Create file for cd-hit-est analysis. miRNAs sequences of mapped miRNAs

        Arguments:
            shift (int): shift of reads to actual miRNA <int> nt up- and downstream
        """
        cdhit_name = self.out_prefix + "references_to_cdhit.fasta"
        cdhit_file = open(cdhit_name, 'w')

        for micro in reduction_dict:
            org_name = new_names[micro]  # take original name of mature miRNA
            #prec_names = self.names[org_name]  # take names of precursors of mature original miRNA
            micro_name = micro.split("::")[0]
            pre_name = micro.split("::")[1] 
            end = micro_name[-2:]
            pre_seq = self.miRNA_dict[pre_name][0]
            prec_info = self.miRNA_dict[pre_name] #start i stop miRNA liczone od 1 w seq ref
            pos = ""
            # get positions of micro to get mature sequence from precursor
            if end == "3p":
                id_end = prec_info[6]
                x = prec_info[3]
                y = prec_info[4]
                if id_end == 'K':
                    pos = (x,y)
                elif id_end == "N":
                    tmp_pos = (int(x)-shift, int(x)+shift,int(y)-shift, int(y)+shift)
                    #positions = {}
                    positions = [[],[]]
                    added = False
                    ccc = 0
                    for r in precursors[pre_name]: #dla każdego odczytu zmapowanego do prekursora
                        if (int(tmp_pos[0]) <= r.start <= int(tmp_pos[1])) and (int(tmp_pos[2]) <= r.stop <= int(tmp_pos[3])) or \
                           (int(tmp_pos[0]) <= r.start <= int(tmp_pos[1])) and (r.stop <= int(tmp_pos[3])) or \
                           (int(tmp_pos[0]) <= r.start) and (int(tmp_pos[2]) <= r.stop <= int(tmp_pos[3])) or \
                            len(pre_seq)/2 <= r.start < r.stop:
                            for _ in range(int(r.read_name.split("_x")[1])):
                                    positions[0].append(int(r.start))
                                    positions[1].append(int(r.stop))
                        else:
                            ccc+=1
                    if positions == [[],[]]:
                        pos = (x,y)
                    else:
                        pos = (round(statistics.mean(positions[0])), round(statistics.mean(positions[1])))

            elif end == "5p":
                id_end = prec_info[5]
                x = prec_info[1]
                y = prec_info[2]
                if id_end == "K":
                    pos = (x,y)
                elif prec_info[5] == "N":
                    tmp_pos = (int(x)-shift, int(x)+shift,int(y)-shift, int(y)+shift)
                    #positions = {}
                    positions = [[],[]]
                    for r in precursors[pre_name]:     
                        if (int(tmp_pos[0]) <= r.start <= int(tmp_pos[1])) and (int(tmp_pos[2]) <= r.stop <= int(tmp_pos[3])) or \
                           (int(tmp_pos[0]) <= r.start <= int(tmp_pos[1])) and (r.stop <= int(tmp_pos[3])) or \
                           (int(tmp_pos[0]) <= r.start) and (int(tmp_pos[2]) <= r.stop <= int(tmp_pos[3])) or \
                            r.start < r.stop <= len(pre_seq)/2:
                            added = True
                            for _ in range(int(r.read_name.split("_x")[1])):
                                    positions[0].append(int(r.start))
                                    positions[1].append(int(r.stop))
                    if positions == [[],[]]:
                        pos = (x,y)

                    else:
                        pos = (round(statistics.mean(positions[0])), round(statistics.mean(positions[1])))
            header = ">{}\n".format(micro)
            sequence = pre_seq[int(pos[0])-1:int(pos[1])]+"\n"
            cdhit_file.write(header)
            cdhit_file.write(sequence)
        cdhit_file.close()
        self.cdhit_name = cdhit_name
        #self.cdhit_name = "../test_results/test_references_to_cdhit.fasta"
        return 

    def run_CDHIT(self): #TODO dokuentacja i komentarz
        """Runs cd-hit-est on fasta file with mapped miRNAs sequences in order to cluster miRNAs based on sequence similarity
           Program parameters:
           -n   word_length, default 10, see user's guide for choosing it
           -c   sequence identity threshold, default 0.9
                this is the default cd-hit's "global sequence identity" calculated as:
                number of identical bases in alignment
                divided by the full length of the shorter sequence
           -g   1 or 0, default 0
                by cd-hit's default algorithm, a sequence is clustered to the first 
                cluster that meet the threshold (fast cluster). If set to 1, the program
                will cluster it into the most similar cluster that meet the threshold
                but either 1 or 0 won't change the representatives of final clusters
           -sf  sort fasta/fastq by cluster size (number of sequences), default 0, no sorting
 	            if set to 1, output sequences by decreasing cluster size
           -sc  sort clusters by size (number of sequences), default 0, output clusters by decreasing length
 	            if set to 1, output clusters by decreasing size
           -d   length of description in .clstr file, default 20
 	            if set to 0, it takes the fasta defline and stops at first space
           -i   name of input file
           -o   name of output file
            Program output: .clstr file with miRNAs grouped in clusters of similar sequences and fasta file with sequences of clusters representatives
        Args:
            name (str): name of input file for cd-hit

        Returns:
            out_file (str): name of output file from cd-hit
        """
        #self.cdhit_name = name
        out_file = self.out_prefix +  "cdhit_result"
        n = 10
        c = 1 
        cmd = "cd-hit-est -n {} -c {} -g 1 -sf 1 -sc 1 -d 0 -i {} -o {}".format(str(n),str(c),self.cdhit_name,out_file)
        stdout = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        _ = codecs.decode(stdout.communicate()[0], 'unicode_escape')
        #cmd = ["cd-hit-est", "-n", str(n), "-c", str(c), "-g", "1", "-sf", "1", "-sc", "1", "-d", "0", "-i", self.cdhit_name, "-o", out_file]
        #print(" ".join(cmd))
        #_ = subprocess.check_output(cmd)
        out_file = out_file + ".clstr"
        return out_file

    def reducing(self, org_id: str, s: float, prnr: int, reduction_dict, ref_clust_file):
        """
        Using reduction.py to reduce reads into miRNA clusters
        and get lists of identified and novel miRNA
        to compile:
        g++ reduce_algorithm.cpp -o reduce_algorithm

        Arguments:
            org_id {str} -- organism id (3-letter shortcut)
            s {float} -- fraction of similar reads for reference in cluster
            q {float} -- fraction of number of reads for reference in cluster
            prnr {int} -- number of processes
            coll {bool} -- flag - if reads are collapsed
            tax_score {dict[str]} -- dictionary of how many miRNAs are in miRBase for organisms in searched taxonomy
            ref_clust_file {str} -- file with CDHIT result

        Returns:
            [str] -- Result of reduction.py = list of pre-miRNA which was clustered to files .clstr identified and novel
        """
        #file_name = self.out_dir + self.out
        #red = reduction.Reduction(file_name, s, ref_clust_file, prnr, True, org_id)
        red = reduction.Reduction(self.out_prefix, s, ref_clust_file, prnr, True, org_id)
        red.matrix_global = reduction_dict.copy()
        red.separator = "_x"
        clusters_result = red.run_reduction()
        red.save_results()
        return clusters_result #, self.names

    def exception_handling(self, msg: str):
        """Print message and exit programme
        
        Arguments:
            msg {str} -- Message to print in error
        """
        sys.stderr.write(msg)
        sys.exit()

    def is_file(self, path: str):
        """Check if file exists
        
        Arguments:
            path {str} -- path to file
        
        Raises:
            FileNotFoundError: file does not exist
        
        Returns:
            bool -- return True if file exists
        """
        if not os.path.isfile(path):
            try:
                raise FileNotFoundError("No such file or directory")
            except FileNotFoundError as e:
                msg = "File error: {0} -> {1}\n".format(e.args[0], path)
                self.exception_handling(msg)
        else:
            return True

    def is_empty(self, path: str):
        """Check if file is not empty
        
        Arguments:
            path {str} -- path to file
        
        Raises:
            Exception: when file is empty
        
        Returns:
            bool -- return False if file is not empty
        """
        if os.path.getsize(path) <= 0:
            try:
                raise Exception(path + " -> file is empty")
            except Exception as e:
                msg = "File error: {0}\n".format(e.args[0])
                self.exception_handling(msg)
        else:
            return False
